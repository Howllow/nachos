### 总体概述



### 任务完成情况

| Exer1 | Exer2 | Exer3 | Exer4 | Exer5 | Exer6 | Challenge1 | Challenge2 |
| ----- | ----- | ----- | ----- | ----- | ----- | ---------- | ---------- |
| Y     |       |       |       |       |       |            |            |

* **Exercise1**

  * **progtest.cc**

    和用户程序执行相关的部分主要是StartProcess函数

    这个函数首先使用fileSyetem的Open方法打开给定的文件，如果打开成功就以构造相应的AddrSpace类的方式来给他分配空间，其工作主要是读取NOFF格式中的信息，从而计算出所用页数量，检查文件是否过大，同时初始化对应页表项，并且读取和执行相关的内容进入内存

    这之后关闭文件，使用AddrSpace中的InitRegisters方法来初始化寄存器的值（包括pcreg，寄存器，下一条指令的NextPcReg，以及StackReg），再使用RestoreState来读取页表信息

    最后使用之前阅读过的machine中的Run方法来逐条指令执行用户程序

    后面的ConsoleTest是用来在控制台输出的，注意需要信号量来维护

  * **machine(.h .cc)**

    * 首先在machine.h中定义了九种exception的类型，以及物理页数目、TLB大小等常数。同时还定义了读写寄存器的方法，剩下的东西都在其他代码中实现。

  * **translate(.h .cc)**

    * 在.h中定义了TranslatoinEntry类，代表一个页表项，其中包括了VPN、PPN以及一些标志位，如只读、dirty、valid等
    * .cc中首先实现了将小端法地址转为大端法表示的函数WordToHost和ShortToHost
    * 实现了Translate函数，功能是将一个虚拟地址翻译为物理地址（使用tlb或者页表，只能使用其中一个），根据不同的异常类型返回不同的异常（如没对齐、虚拟页号过大、tlbmiss、只读错误、总线错误或者没有异常），而物理地址保存在给定的参数指向的位置
    * .cc中还有读取内存的ReadMem函数，功能是将一定大小的指定虚存处的内容读取到给定的location。首先需要使用Translate翻译虚拟地址，抛出不同的异常，没有异常就根据所给size来调用ShortToHost或者WordToHost来翻译结果
    * WriteMem基本同理，只是将读取操作换为了保存操作

  * **exception.cc**

    提供异常处理函数接口，目前只有一个Halt，其余的需要我们自己实现

* **Exercise2 & 3**

  首先我们需要知道tlb会抛出哪些异常

  在translate.cc中可以发现，当entry==NULL，即tlb miss的时候，会抛出一个PageFaultException；当尝试写一个只读页的时候会抛出ReadOnlyException；当得到的物理页框号大于物理页数目时，会抛出BusErrorException。我们这里需要处理的是PageFaultException。

  首先在ExcetionHandler中加入判断

  ~~~C
  else if ((which == PageFaultException) && (tlb != NULL)) {
      	TLBMissHandler(1);
      }
  ~~~

  为了判断是tlbmiss所引发的异常，需要判断tlb是不是非NULL，这里调用我们将要实现的TLBMissHandler（传入的参数表示选用不同的置换策略）

  