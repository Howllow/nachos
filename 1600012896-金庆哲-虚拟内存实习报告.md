### 总体概述



### 任务完成情况

| Exer1 | Exer2 | Exer3 | Exer4 | Exer5 | Exer6 | Challenge1 | Challenge2 |
| ----- | ----- | ----- | ----- | ----- | ----- | ---------- | ---------- |
| Y     |       |       |       |       |       |            |            |

* **Exercise1**

  * **progtest.cc**

    和用户程序执行相关的部分主要是StartProcess函数

    这个函数首先使用fileSyetem的Open方法打开给定的文件，如果打开成功就以构造相应的AddrSpace类的方式来给他分配空间，其工作主要是读取NOFF格式中的信息，从而计算出所用页数量，检查文件是否过大，同时初始化对应页表项，并且读取和执行相关的内容进入内存

    这之后关闭文件，使用AddrSpace中的InitRegisters方法来初始化寄存器的值（包括pcreg，寄存器，下一条指令的NextPcReg，以及StackReg），再使用RestoreState来读取页表信息

    最后使用之前阅读过的machine中的Run方法来逐条指令执行用户程序

    后面的ConsoleTest是用来在控制台输出的，注意需要信号量来维护

  * **machine(.h .cc)**

    * 首先在machine.h中定义了九种exception的类型，以及物理页数目、TLB大小等常数。同时还定义了读写寄存器的方法，剩下的东西都在其他代码中实现。

  * **translate(.h .cc)**

    * 在.h中定义了TranslatoinEntry类，代表一个页表项，其中包括了VPN、PPN以及一些标志位，如只读、dirty、valid等
    * .cc中首先实现了将小端法地址转为大端法表示的函数WordToHost和ShortToHost
    * 实现了Translate函数，功能是将一个虚拟地址翻译为物理地址（使用tlb或者页表，只能使用其中一个），根据不同的异常类型返回不同的异常（如没对齐、虚拟页号过大、tlbmiss、只读错误、总线错误或者没有异常），而物理地址保存在给定的参数指向的位置
    * .cc中还有读取内存的ReadMem函数，功能是将一定大小的指定虚存处的内容读取到给定的location。首先需要使用Translate翻译虚拟地址，抛出不同的异常，没有异常就根据所给size来调用ShortToHost或者WordToHost来翻译结果
    * WriteMem基本同理，只是将读取操作换为了保存操作

  * **exception.cc**

    提供异常处理函数接口，目前只有一个Halt，其余的需要我们自己实现

* **Exercise2 & 3**

  在当前的实现机制中，物理页面全部进入内存，所以页表并不会出现失效，因此我们只需要处理TLB的失效问题

  首先我们需要知道tlb会抛出哪些异常

  在translate.cc中可以发现，当entry==NULL，即tlb miss的时候，会抛出一个PageFaultException；当尝试写一个只读页的时候会抛出ReadOnlyException；当得到的物理页框号大于物理页数目时，会抛出BusErrorException。我们这里需要处理的是PageFaultException。

  首先在ExcetionHandler中加入判断

  ~~~C
  else if ((which == PageFaultException) && (tlb != NULL)) {
      	TLBMissHandler(1);
      }
  ~~~

  为了判断是tlbmiss所引发的异常，需要判断tlb是不是非NULL，这里调用我们将要实现的TLBMissHandler（传入的参数表示选用不同的置换策略）

  我们先来考虑一下处理这个异常的逻辑，首先我们肯定是要定位需要的页面，然后想办法将这个页面放入到tlb中，这里就分为两种情况

  * 如果tlb没有满，就将搜到的第一个空位分给这个页面
  * 如果tlb满了，需要根据不同的置换策略来选择换出页面
    * FIFO：tlb首端的页面必定是最先进入的，换出，然后将我们的页面放到末尾
    * LRU：选择最久没有使用的页面换出

    那么抛出异常后，我们应该去哪里找到这个访问失败的虚拟地址呢？在machine.h中可以发现，这个地址被存放在BadVAddrReg中。

    我们给Machine类加入一个公共list变量TLBList，在构造函数中将其初始化。然后我们再定义一个class TLBPos

  ~~~c++
  class TLBPos {
  	public:
  		int index;
  		int lru;
  		TLBPos(int i) {
  			index = i;
              lru = 0;
  		};
  };
  ~~~

  下面是两种策略的实现方式

  先用registers[BadVAddrReg]中的地址算出VPN

  检查TLBList中元素数目是否小于TLB的size，如果小于，那么我们搜索找到第一个空位分配给这个页面即可，然后将一个TLBPos插入TLBList中即可（这里注意需要使用sortedInsert，以便后面LRU的实现，同时不要忘了如果是LRU的话要进行LRU值的处理！！！！）。

  如果判断出TLBList中元素数目等于TLB的size，那么就说明需要找一个页面换出了（这里的换出实际上是改写tlb表项的内容。

  * FIFO

    由于在FIFO中sortedInsert并没有起作用，相当于是Append，那么在队列首部的元素的index就代表最先进入tlb的页面在tlb数组中的编号。

    ~~~C
    TLBPos* tmp = machine->TLBList->Remove();
    int index = tmp->index;
    machine->TLBList->SortedInsert(tmp, tmp->lru);
    ~~~

  * LRU

    对于LRU而言，当TLB命中的时候，需要修改TLBList中的元素，让所有没有使用的元素的lru值减一（为了使用sortedInsert的时候让最久没有使用的元素在首部），先在machine.h中定义一个函数ChangeLRU

    ~~~C++
    void 
    ChangeLRU(TLBPos* a, int index)
    {
    		if (a->index != index)
    			a->lru--;
    		return;
    }
    ~~~

    为了方便，在List类中加入了一个Change函数（这里其实应该用继承更符合逻辑一点，不过这样也没什么影响）

    ~~~C++
    void
    List::Change(int index)
    {
        for (ListElement *ptr = first; ptr != NULL; ptr = ptr->next) {
           ChangeLRU((TLBPos*) (ptr)->item, index);
        }
    }
    ~~~

    

    在translate.cc中命中的部分加入以下代码

      ~~~C++
    	TLBList->Change(i);
    	
      ~~~

    而当TLBMiss时，如果tlb不是满的，那依旧找到一个空位分配给页面即可。如果是满的，此时TLBList头部的元素依旧是最久没有访问的页面，换出即可，但是换出之后依旧需要进行一次ChangeLRU的操作。这里先进行四次remove和insert保证list有序(SortTLBList函数)

    ~~~C++
            SortTLBList();
            TLBPos* tmp = machine->TLBList->Remove();
            index = tmp->index;
            tmp->lru = 0;
            machine->TLBList->Change(index);
            machine->TLBList->SortedInsert(tmp, tmp->lru);
    ~~~

    最后将index处的TLB表项的内容改变即可

    ~~~c++
    machine->tlb[index].valid = TRUE;
    machine->tlb[index].virtualPage = vpn;
    machine->tlb[index].physicalPage = machine->pageTable[vpn].physicalPage;
    machine->tlb[index].use = FALSE;
    machine->tlb[index].dirty = FALSE;
    machine->tlb[index].readOnly = FALSE;
    ~~~

    

    为了测试TLB，我们需要修改userprog文件夹中的Makefile中的DEFINES，加入-DUSE_TLB，同时还需要加入全局变量统计miss和hit的次数，以及miss rate

    这里考虑使用matmult程序进行测试，但是发现了两个问题，在后面的问题中解释

    首先来看FIFO的结果

    ![TIM截图20190331215216](E:\Users\Administrator\PycharmProjects\nachos\assets\TIM截图20190331215216-1554040357644.png)

    然后是LRU的结果

    ![TIM截图20190331215041](E:\Users\Administrator\PycharmProjects\nachos\assets\TIM截图20190331215041.png)

    可以看到LRU的missrate是低于FIFO的，符合逻辑。

    （第一部分遇到了很多的坑，放在后面讲）

    