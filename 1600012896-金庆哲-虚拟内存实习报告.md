### 总体概述



### 任务完成情况

| Exer1 | Exer2 | Exer3 | Exer4 | Exer5 | Exer6 | Challenge1 | Challenge2 |
| ----- | ----- | ----- | ----- | ----- | ----- | ---------- | ---------- |
| Y     | Y     | Y     | Y     |       |       |            |            |

* **Exercise1**

  * **progtest.cc**

    和用户程序执行相关的部分主要是StartProcess函数

    这个函数首先使用fileSyetem的Open方法打开给定的文件，如果打开成功就以构造相应的AddrSpace类的方式来给他分配空间，其工作主要是读取NOFF格式中的信息，从而计算出所用页数量，检查文件是否过大，同时初始化对应页表项，并且读取和执行相关的内容进入内存

    这之后关闭文件，使用AddrSpace中的InitRegisters方法来初始化寄存器的值（包括pcreg，寄存器，下一条指令的NextPcReg，以及StackReg），再使用RestoreState来读取页表信息

    最后使用之前阅读过的machine中的Run方法来逐条指令执行用户程序

    后面的ConsoleTest是用来在控制台输出的，注意需要信号量来维护

  * **machine(.h .cc)**

    * 首先在machine.h中定义了九种exception的类型，以及物理页数目、TLB大小等常数。同时还定义了读写寄存器的方法，剩下的东西都在其他代码中实现。

  * **translate(.h .cc)**

    * 在.h中定义了TranslatoinEntry类，代表一个页表项，其中包括了VPN、PPN以及一些标志位，如只读、dirty、valid等
    * .cc中首先实现了将小端法地址转为大端法表示的函数WordToHost和ShortToHost
    * 实现了Translate函数，功能是将一个虚拟地址翻译为物理地址（使用tlb或者页表，只能使用其中一个），根据不同的异常类型返回不同的异常（如没对齐、虚拟页号过大、tlbmiss、只读错误、总线错误或者没有异常），而物理地址保存在给定的参数指向的位置
    * .cc中还有读取内存的ReadMem函数，功能是将一定大小的指定虚存处的内容读取到给定的location。首先需要使用Translate翻译虚拟地址，抛出不同的异常，没有异常就根据所给size来调用ShortToHost或者WordToHost来翻译结果
    * WriteMem基本同理，只是将读取操作换为了保存操作

  * **exception.cc**

    提供异常处理函数接口，目前只有一个Halt，其余的需要我们自己实现

* **Exercise2 & 3**

  在当前的实现机制中，物理页面全部进入内存，所以页表并不会出现失效，因此我们只需要处理TLB的失效问题

  首先我们需要知道tlb会抛出哪些异常

  在translate.cc中可以发现，当entry==NULL，即tlb miss的时候，会抛出一个PageFaultException；当尝试写一个只读页的时候会抛出ReadOnlyException；当得到的物理页框号大于物理页数目时，会抛出BusErrorException。我们这里需要处理的是PageFaultException。

  首先在ExcetionHandler中加入判断

  ~~~C
  else if ((which == PageFaultException) && (tlb != NULL)) {
      	TLBMissHandler(1);
      }
  ~~~

  为了判断是tlbmiss所引发的异常，需要判断tlb是不是非NULL，这里调用我们将要实现的TLBMissHandler（传入的参数表示选用不同的置换策略）

  我们先来考虑一下处理这个异常的逻辑，首先我们肯定是要定位需要的页面，然后想办法将这个页面放入到tlb中，这里就分为两种情况

  * 如果tlb没有满，就将搜到的第一个空位分给这个页面
  * 如果tlb满了，需要根据不同的置换策略来选择换出页面
    * FIFO：tlb首端的页面必定是最先进入的，换出，然后将我们的页面放到末尾
    * LRU：选择最久没有使用的页面换出

    那么抛出异常后，我们应该去哪里找到这个访问失败的虚拟地址呢？在machine.h中可以发现，这个地址被存放在BadVAddrReg中。

    我们给Machine类加入一个公共list变量TLBList，在构造函数中将其初始化。然后我们再定义一个class TLBPos

  ~~~c++
  class TLBPos {
  	public:
  		int index;
  		int lru;
  		TLBPos(int i) {
  			index = i;
              lru = 0;
  		};
  };
  ~~~

  下面是两种策略的实现方式

  先用registers[BadVAddrReg]中的地址算出VPN

  检查TLBList中元素数目是否小于TLB的size，如果小于，那么我们搜索找到第一个空位分配给这个页面即可，然后将一个TLBPos插入TLBList中即可（这里注意需要使用sortedInsert，以便后面LRU的实现，同时不要忘了如果是LRU的话要进行LRU值的处理！！！！）。

  如果判断出TLBList中元素数目等于TLB的size，那么就说明需要找一个页面换出了（这里的换出实际上是改写tlb表项的内容。

  * FIFO

    在队列首部的元素的index就代表最先进入tlb的页面在tlb数组中的编号。

    ~~~C
    TLBPos* tmp = machine->TLBList->Remove();
    int index = tmp->index;
    machine->TLBList->Append(tmp);
    ~~~

  * LRU

    对于LRU而言，当TLB命中的时候，需要修改TLBList中的元素，让所有没有使用的元素的lru值减一，让被使用的元素的lru值重置为0，先在machine.h中定义一个函数ChangeLRU

    ~~~C++
    void 
    ChangeLRU(TLBPos* a, int index)
    {
    		if (a->index != index)
    			a->lru--;
    		return;
    }
    ~~~

    为了方便，在List类中加入了一个Change函数（这里其实应该用继承更符合逻辑一点，不过这样也没什么影响）

    ~~~C++
    void
    List::Change(int index)
    {
        for (ListElement *ptr = first; ptr != NULL; ptr = ptr->next) {
           ChangeLRU((TLBPos*) (ptr)->item, index);
        }
    }
    ~~~

    

    在translate.cc中命中的部分加入以下代码

      ~~~C++
    	TLBList->Change(i);
    	
      ~~~

    而当TLBMiss时，如果tlb不是满的，那依旧找到一个空位分配给页面即可。如果是满的，此时TLBList头部的元素依旧是最久没有访问的页面，换出即可，但是换出之后依旧需要进行一次ChangeLRU的操作。这里先进行四次remove和insert保证list有序(SortTLBList函数)

    ~~~C++
            SortTLBList();
            TLBPos* tmp = machine->TLBList->Remove();
            index = tmp->index;
            tmp->lru = 0;
            machine->TLBList->Change(index);
            machine->TLBList->SortedInsert(tmp, tmp->lru);
    ~~~

    最后将index处的TLB表项的内容改变即可

    ~~~c++
    machine->tlb[index].valid = TRUE;
    machine->tlb[index].virtualPage = vpn;
    machine->tlb[index].physicalPage = machine->pageTable[vpn].physicalPage;
    machine->tlb[index].use = FALSE;
    machine->tlb[index].dirty = FALSE;
    machine->tlb[index].readOnly = FALSE;
    ~~~

    

    为了测试TLB，我们需要修改userprog文件夹中的Makefile中的DEFINES，加入-DUSE_TLB，同时还需要加入全局变量统计miss和hit的次数，以及miss rate

    这里考虑使用matmult程序进行测试，但是发现了两个问题，在后面的问题中解释

    首先来看FIFO的结果

    ![TIM截图20190331215216](E:\Users\Administrator\PycharmProjects\nachos\assets\TIM截图20190331215216-1554040357644.png)

    然后是LRU的结果

    ![TIM截图20190331215041](E:\Users\Administrator\PycharmProjects\nachos\assets\TIM截图20190331215041.png)

    可以看到LRU的missrate是低于FIFO的，符合逻辑。

    （第一部分遇到了很多的坑，放在后面讲）

* **Exercise4**

  在这个部分我们需要实现一个全局内存管理数据结构，注意到在userprog文件夹中已经给我们提供了一个十分方便的BitMap类，那么我们就使用位图来管理内存。

  首先需要在machine中定义一个BitMap* MemoryMap，在构造函数中将其初始化为大小为NumPhysPages的BitMap实例。

  然后我们需要修改addrspace.cc中的分配物理页号的部分，原本物理页号和虚拟页号相同，现在改为

  ~~~C++
  pageTable[i].physicalPage = machine->MemoryMap->Find();
  ASSERT(pageTable[i].physicalPage != -1);
  ~~~

  这样可以分配第一个找到的空位置给物理页。

  实现了分配，我们还要考虑何时回收分配的内存，注意到用户程序中都会进行Exit(0)的系统调用（事实上也是之前遇到的问题之一），所以我们可以考虑使用Exit的handler来回收内存。

  首先我们需要将machine中的MemoryMap的每一位清零，并将machine页表清空（全部置为初始状态），至于内存的实际清空在后面的部分中实现。

  ~~~C++
  void
  ExitHandler()
  {
      for (int i = 0; i < machine->pageTableSize; i++) {
          machine->pageTable[i].valid = FALSE;
          machine->pageTable[i].use = FALSE;
          machine->pageTable[i].dirty = FALSE;
          machine->pageTable[i].readOnly = FALSE; 
          machine->MemoryMap->Clear(machine->pageTable[i].physicalPage);
      }
      machine->WriteRegister(PCReg, machine->ReadRegister(NextPcReg));
  
  }
  ~~~

  上面是handler的实现，可以看到最后多了一步设置PC寄存器的操作，这是由于在OneInstruction中执行系统调用是直接RaiseException，而无法break来执行后面的设置新PC的操作，所以需要我们手动设置。

  测试结果如下图

  

  ​    ![TIM截图20190401210717](C:\Users\Administrator\Desktop\TIM截图20190401210717.png)

* **Exercise5**

  在这个部分我们需要让Nachos支持多个线程

  现在Nachos对于线程内存的管理方法是：在初始化用户空间的时候，会用bzero函数将machine中的mainMemory完全清零，然后将内容写入，因此只能有一个在主存中的线程

  为了实现多线程，我们需要改变清零和写入的机制，我们在E4中已经改变了虚拟页的分配方式，因此只需要让用户程序中的虚拟页映射到某些物理页上，这样就可以让主存中存放多个线程的页面。

  首先需要修改的就是AddrSpace的构造函数中的分配部分，在find到一个空页面并初始化也pageTable信息之后加入一句

  ~~~C++
  bzero(machine->mainMemory + ppn * PageSize, PageSize);
  ~~~

  这样就可以只将所需要的页面清零以便后面使用

  之后就是要考虑页面的写入，原来是将整个noffH的code段和initData段直接读进mainMemory覆盖，现在我们需要将其读取到我们给定的页面中，这里使用按字节读入的方法（更方便实现）。

  ~~~C++
  if (noffH.code.size > 0) {
          DEBUG('a', "Initializing code segment, at 0x%x, size %d\n", 
  			noffH.code.virtualAddr, noffH.code.size);
  		int nowpos = noffH.code.inFileAddr;
          for (int k = 0; k < noffH.code.size; k++) {
              int vpn = (noffH.code.virtualAddr + k) / PageSize; // calculate in which page this byte is
              int offset = noffH.code.virtualAddr + k - vpn * PageSize; // calculate the offset in this page
              int paddr = pageTable[vpn].physicalPage * PageSize + offset; // calculate the addr in mainMemory
              executable->ReadAt(&(machine->mainMemory[paddr]), 1, nowpos++);
          }
      }
  ~~~

  如代码所示，先计算虚拟页号，再计算在页面下的偏移量，然后可以计算出在mainMemory中的物理地址，最后使用ReadAt来读取一字节，initData同理

  最后我们要考虑的就是切换线程空间时的处理，因为切换空间后tlb中的表项会全部失效，所以要将machine中tlb的valid全都置为false，这个操作在AddrSpace::SaveState中完成（原本是空的）

  接下来就是测试环节，为了创建两个线程来运行两个不同的用户程序

  ~~~C++
  void
  NewProg(char* filename)
  {
      OpenFile *executable = fileSystem->Open(filename);
      AddrSpace *testspace;
      testspace = new AddrSpace(executable);
      currentThread->space = testspace;
      delete executable;          // close file
  
      space->InitRegisters();     // set the initial register values
      space->RestoreState();      // load page table register
      machine->Run();
  }
  ~~~

  我们用上面的函数来Fork一个新线程，传入的参数是StartProcess中的filename，在原本的machine->Run()之后加入Fork过程

  因为只是为了检查分配页面的正确，所以我们就用最简单的用户程序halt进行测试，结果如下图

  ![TIM截图20190401222656](E:\Users\Administrator\PycharmProjects\nachos\assets\TIM截图20190401222656.png)

  可以看到成功的让两个线程共同使用了mainMemory

  

* **Exercise6**

  